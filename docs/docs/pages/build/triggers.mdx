# Triggers

You can have one query trigger another query.

Triggered queries can bypass access control rules, so this comes in handy when updating one collection owned by a user and another collection not owned by the same person.

For example, a user likes a tweet, which triggers an increment of the like count that the user doesn't have access to update.

You can think of it as an equivalent to [Firestore Triggers](https://firebase.google.com/docs/functions/firestore-events?gen=2nd). It's an essential component when building apps.

## Add Triggers

- `key` : name of the trigger
- `on` : create | update | delete
- `fn` : FPJSON logic
- `fields` : fields to match (match anything if not specified)
- `match` : all | any | none (default to `any`)

If `fields` is specified, the `fn` is triggered only the fields are changed with the specified `match` type.

[FPJSON](https://fpjson.weavedb.dev/) will get an object containing the data `before` and `after` the change.

```javascript
let vars = { before, after, db, dir, doc, owner, signer, signer23, ts, ts64 }

```

A trigger to increment the like count.

```javascript
const { expect } = require("chai")

const trigger = {
  key: "inc_likes",
  on: "create",
  fn: [["update", [{ likes: { _$: ["inc"] }, "notes", "$after.object"]]],
  fields: [ "object" ]
  match: "any"
}
await db.addTrigger(trigger, "likes")

// like a note
await db.set("add:like", { object: noteId }, "likes")

// likes has been incremented
assert.equal((await db.get("notes", noteId)).likes, 1)
```
## Get Triggers

```js
const triggers = (await db.stat("likes")).triggers ?? {}
```

## Remove Triggers

Specify the trigger key to remove.

```javascript
await db.removeTrigger({ key: "inc_likes" }, "likes")
```
