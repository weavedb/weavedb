# FPJSON (Functional Programmable JSON)

![](/images/fpjson.png)

FPJSON is a dmain specific language (DSL) for WeaveDB, and what makes a fully decentralized DB possible.

Apart from performance and scalability, you cannot just bring in an existing web2 database and decentralize it. A web3 database requires highly advanced logic around data ownerships, programmable data manipurations, and access control rules due to the permissionless nature.

Unlike web2 databases with only a few access gateways for admin users, anyone can write anything to a web3 DB from anywhere. We need precise controls over everything but in a decentralized fashion.

WeaveDB has decentralized features such as

- **Crypto Account Authentication** to manage data access and ownerships
- **Data Schemas** to constrain stored data format
- **Access Control Rules** to manage write permissions and manipulate data
- **Crons** to periodically execute queries
- **Triggers** to chain queries with pre-defined logic
- **Verifiable Relayers** to bring in data from outside data sources

:::warning
Crons and Relayers are not implemented on the new WeaveDB on HyperBEAM yet.
:::

Without these features, a web3 database would either be out of control or have only limited use cases. And all these are enabled by FPJSON as the simplest JSON style settings. FPJSON enables highly advanced, and composable functional programming in a simple JSON format, which makes WeaveDB itself the most powerful smart contract sandbox as well.

## Basic FPJSON Blocks

FPJSON is based upon [Ramda.js](https://ramdajs.com/) which comes from the functional programming ecosystem (I believe it's heavily inspired by [Haskell](https://www.haskell.org/)). You can use most of the [250+ pre-defined Ramda functions](https://fpjson.weavedb.dev/), and compose them in any depth of complexity, but in a simple JSON array format. The biggest advantage of JSON style programming is we can store any logic as a JSON data object as a smart contract state and reuse them to compose with other logic. This is the only viable (yet super powerful) way to dynamically construct, compose and extend logic after smart contract is immutably deployed without deploying a new contract.

Basic FPJSON blocks look something like these.

```js

["add", 1, 2] // = 3

["difference", [1, 2, 3], [3, 4, 5]] // = [1, 2]

[["map", ["inc"]], [1, 2, 3]] // = [4, 5, 6]

[["compose", ["map", ["inc"]], ["difference"]], [1, 2, 3], [2]] // = [2, 4]
```
Learn the 250+ powerful functions [here](https://fpjson.weavedb.dev).
