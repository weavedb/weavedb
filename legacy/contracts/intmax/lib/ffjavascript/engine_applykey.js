import BigBuffer from "./bigbuffer.js"

export default function buildBatchApplyKey(curve, groupName) {
  const G = curve[groupName]
  const Fr = curve.Fr
  const tm = curve.tm

  curve[groupName].batchApplyKey = async function (
    buff,
    first,
    inc,
    inType,
    outType
  ) {
    inType = inType || "affine"
    outType = outType || "affine"
    let fnName, fnAffine
    let sGin, sGmid, sGout
    if (groupName == "G1") {
      if (inType == "jacobian") {
        sGin = G.F.n8 * 3
        fnName = "g1m_batchApplyKey"
      } else {
        sGin = G.F.n8 * 2
        fnName = "g1m_batchApplyKeyMixed"
      }
      sGmid = G.F.n8 * 3
      if (outType == "jacobian") {
        sGout = G.F.n8 * 3
      } else {
        fnAffine = "g1m_batchToAffine"
        sGout = G.F.n8 * 2
      }
    } else if (groupName == "G2") {
      if (inType == "jacobian") {
        sGin = G.F.n8 * 3
        fnName = "g2m_batchApplyKey"
      } else {
        sGin = G.F.n8 * 2
        fnName = "g2m_batchApplyKeyMixed"
      }
      sGmid = G.F.n8 * 3
      if (outType == "jacobian") {
        sGout = G.F.n8 * 3
      } else {
        fnAffine = "g2m_batchToAffine"
        sGout = G.F.n8 * 2
      }
    } else if (groupName == "Fr") {
      fnName = "frm_batchApplyKey"
      sGin = G.n8
      sGmid = G.n8
      sGout = G.n8
    } else {
      throw new Error("Invalid group: " + groupName)
    }
    const nPoints = Math.floor(buff.byteLength / sGin)
    const pointsPerChunk = Math.floor(nPoints / tm.concurrency)
    const opPromises = []
    inc = Fr.e(inc)
    let t = Fr.e(first)
    for (let i = 0; i < tm.concurrency; i++) {
      let n
      if (i < tm.concurrency - 1) {
        n = pointsPerChunk
      } else {
        n = nPoints - i * pointsPerChunk
      }
      if (n == 0) continue

      const task = []

      task.push({
        cmd: "ALLOCSET",
        var: 0,
        buff: buff.slice(
          i * pointsPerChunk * sGin,
          i * pointsPerChunk * sGin + n * sGin
        ),
      })
      task.push({ cmd: "ALLOCSET", var: 1, buff: t })
      task.push({ cmd: "ALLOCSET", var: 2, buff: inc })
      task.push({ cmd: "ALLOC", var: 3, len: n * Math.max(sGmid, sGout) })
      task.push({
        cmd: "CALL",
        fnName: fnName,
        params: [{ var: 0 }, { val: n }, { var: 1 }, { var: 2 }, { var: 3 }],
      })
      if (fnAffine) {
        task.push({
          cmd: "CALL",
          fnName: fnAffine,
          params: [{ var: 3 }, { val: n }, { var: 3 }],
        })
      }
      task.push({ cmd: "GET", out: 0, var: 3, len: n * sGout })

      opPromises.push(tm.queueAction(task))
      t = Fr.mul(t, Fr.exp(inc, n))
    }

    const result = await Promise.all(opPromises)

    let outBuff
    if (buff instanceof BigBuffer) {
      outBuff = new BigBuffer(nPoints * sGout)
    } else {
      outBuff = new Uint8Array(nPoints * sGout)
    }

    let p = 0
    for (let i = 0; i < result.length; i++) {
      outBuff.set(result[i][0], p)
      p += result[i][0].byteLength
    }

    return outBuff
  }
}
