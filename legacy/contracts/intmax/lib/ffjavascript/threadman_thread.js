/* global WebAssembly */

export default function thread(self) {
  const MAXMEM = 32767
  let instance
  let memory

  if (self) {
    self.onmessage = function (e) {
      let data
      if (e.data) {
        data = e.data
      } else {
        data = e
      }

      if (data[0].cmd == "INIT") {
        init(data[0]).then(function () {
          self.postMessage(data.result)
        })
      } else if (data[0].cmd == "TERMINATE") {
        self.close()
      } else {
        const res = runTask(data)
        self.postMessage(res)
      }
    }
  }

  async function init(data) {
    const code = new Uint8Array(data.code)
    const wasmModule = await WebAssembly.compile(code)
    memory = new WebAssembly.Memory({ initial: data.init, maximum: MAXMEM })

    instance = await WebAssembly.instantiate(wasmModule, {
      env: {
        memory: memory,
      },
    })
  }

  function alloc(length) {
    const u32 = new Uint32Array(memory.buffer, 0, 1)
    while (u32[0] & 3) u32[0]++ // Return always aligned pointers
    const res = u32[0]
    u32[0] += length
    if (u32[0] + length > memory.buffer.byteLength) {
      const currentPages = memory.buffer.byteLength / 0x10000
      let requiredPages = Math.floor((u32[0] + length) / 0x10000) + 1
      if (requiredPages > MAXMEM) requiredPages = MAXMEM
      memory.grow(requiredPages - currentPages)
    }
    return res
  }

  function allocBuffer(buffer) {
    const p = alloc(buffer.byteLength)
    setBuffer(p, buffer)
    return p
  }

  function getBuffer(pointer, length) {
    const u8 = new Uint8Array(memory.buffer)
    return new Uint8Array(u8.buffer, u8.byteOffset + pointer, length)
  }

  function setBuffer(pointer, buffer) {
    const u8 = new Uint8Array(memory.buffer)
    u8.set(new Uint8Array(buffer), pointer)
  }

  function runTask(task) {
    if (task[0].cmd == "INIT") {
      return init(task[0])
    }
    const ctx = {
      vars: [],
      out: [],
    }
    const u32a = new Uint32Array(memory.buffer, 0, 1)
    const oldAlloc = u32a[0]
    for (let i = 0; i < task.length; i++) {
      switch (task[i].cmd) {
        case "ALLOCSET":
          ctx.vars[task[i].var] = allocBuffer(task[i].buff)
          break
        case "ALLOC":
          ctx.vars[task[i].var] = alloc(task[i].len)
          break
        case "SET":
          setBuffer(ctx.vars[task[i].var], task[i].buff)
          break
        case "CALL": {
          const params = []
          for (let j = 0; j < task[i].params.length; j++) {
            const p = task[i].params[j]
            if (typeof p.var !== "undefined") {
              params.push(ctx.vars[p.var] + (p.offset || 0))
            } else if (typeof p.val != "undefined") {
              params.push(p.val)
            }
          }
          instance.exports[task[i].fnName](...params)
          break
        }
        case "GET":
          ctx.out[task[i].out] = getBuffer(
            ctx.vars[task[i].var],
            task[i].len
          ).slice()
          break
        default:
          throw new Error("Invalid cmd")
      }
    }
    const u32b = new Uint32Array(memory.buffer, 0, 1)
    u32b[0] = oldAlloc
    return ctx.out
  }

  return runTask
}
